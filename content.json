{"Lập trình game có thể giúp thiếu niên bớt nghiện game":"Sau một thời gian quan sát rất nhiều sinh viên đang học và đã tốt nghiệp đại học có biểu hiện nghiện chơi games đến Techmaster thực tập, tôi thấy rằng chơi games gây nghiện rất cao. Nếu người chơi không nghiện, hãng sản xuất games sẽ phá sản.\n\nĐể dứt nghiện với nhiều em không thể chỉ khuyên nhủ, doạ dẫm mà phải có hoạt động thú vị hơn lôi các em ra khỏi phòng máy tính:\n\n\n\nCho thanh thiếu niên tham gia hoạt động tập thể với bạn bè nhiều hơn.\nChơi các môn thể thao như bơi, võ thuật, bóng bàn, chạy bộ, thể hình càng nhiều càng tốt.\nĐi dã ngoại ra xa khỏi vùng có truy cập Internet. Khoảng 3 tuần 1 lần.\nKiếm một việc làm thêm trong hè nếu có thể.\nTham gia một khoá học ít lý thuyết suông, không thi cử căng thẳng, không đánh giá điểm số ăn thua, không thầy cô mà chỉ có người hướng dẫn trẻ, nhiệt huyết làm ra sản phẩm nhìn được, sờ được, chơi được, ăn được, bán được. Phải rất cụ thể để đưa các em về thực tại.\nChơi game và lập trình game là hai việc hoàn toàn khác nhau. Chơi game thì cần phản xạ nhanh: mắt, tay bấm chuột, gõ bàn phím, chơi nhiều thành lối mòn trong não bộ, khiến người chơi không muốn thử làm những việc khác trong thực tế, dẫn đến việc thu mình - lười lao động.  Hệ thống thưởng điểm, thưởng đồ, nâng cấp thứ bậc trong game khiến người chơi cảm giác thua thì ít, mà thắng là chủ yếu. Ngược lại lập trình games là một công việc nghiêm túc cần quan sát, tư duy logic, suy nghĩ hình dung giải pháp để hiện thực hoá kích bản trong game, kỹ năng lập trình và thiết kế đồ hoạ, tạo hiệu ứng âm thanh cần phải phối hợp nhịp nhàng.\n\nLập trình viên sẽ không có cơ hội tạo ra phản xạ vô thức thành thói quen, mà liên tục phải động não để giải quyết vấn đề mới liên tục phát sinh.\n\nĐiều này cũng tương tự một người nghiện ăn uống khác với môt người thích nấu nướng.\n\n\n\n\nLập trình để một quả bóng rơi, học viên cần hiểu gia tốc trọng trường, liên hệ giữa quãng đường, vận tốc, gia tốc. Hay va đập giữa phi thuyền và các hành tinh cũng là hiện tượng vật lý va chạm giữa 2 vật thể rắn. Mọi khoá học ở Techmaster tuy ẩn đi phần lý thuyết nhưng nó lại bắt học viên phải liên hệ lại những kiến thức toán, vật lý đã - sẽ học ở trường để lập trình.\n\nTôi chọn dạy lập trình game Phaser.io bởi sản phẩm các cháu lập trình chơi ngay trên trình duyệt của desktop, thiết bị di động, không phải cài đặt hay cập nhật. Các cháu nên chia sẻ sản phẩm của mình cho bạn bè, anh chị , bố mẹ coi thử. Sản phẩm của Phaser.io không nhất thiết là games, mà có thể là ứng dụng dạy học, một hoạt cảnh nhưng đáy biển với nhiều loài cá, hay một phi thuyền bay qua dải ngân hà, hay một con ếch nhảy qua các đám hoa súng trên hồ, hay một máy bắn đá....\n\n\n\n\nViệc giới thiệu sản phẩm, thuyết phục bạn bè dùng thử sản phẩm sẽ dạy các cháu kỹ năng bàn hàng tự nhiên nhất. Có quá nhiều cử nhân tốt nghiệp ra chỉ mong xin việc chân tay hoặc thụ động - an nhàn, ít phải động não, ít va vấp nhất có thể. Kết quả là Việt nam cử nhân, thạc sỹ chạy Grab bike đông hơn rất rất nhiều kỹ sư nghiên cứu, phát triển sản phẩm.\n\nTrên đây là kinh nghiệm cá nhân, đã quan sát trên một tập khoảng 300 thanh niên độ tuổi từ 19- 28 tuổi. Cũng như loại hình nghiện khác, chơi games có thể tái nghiện khi thanh thiếu niên không chịu được thất bại, thách thức ngoài đời thường dẫn đến họ quay về với môi trường ảo, ở đó kỹ năng chơi games của họ được phát huy tốt. Do đó việc cai nghiện game cần là một quá trình mà phụ huynh, anh chị, người thân, giảng viên tạo niềm vui , động lực kéo người nghiện ra khỏi thế giới ảo.\n\nVẫn có một số nhỏ thanh niên sau khi theo học nghề ở Techmaster bỏ cuộc, quay lại việc chơi game, lúc này họ hoàn toàn đầu hàng, rút lui khỏi cuộc sống thật.\n\n","[IoT] So sánh 4 mô hình truyền thông trong hệ thống IoT":"Bài toán truyền thông trong IoT chủ yếu liên quan tới những vấn đề phát sinh trong việc truyền thông giữa 3 nhóm: thiết bị, gateways và Cloud. Cụ thể hơn thì quá trình truyền thông đó chủ yếu liên quan tới trao đổi message(thông điệp). Việc trao đổi message thường tuân theo một mô hình truyền thông nhất định. Và với mỗi mô hình truyền thông thì cách trao đổi message lại khác nhau đôi chút. Để lựa chọn được giải pháp truyền thông phù hợp cho sản phẩm IoT, chúng ta nên xem xét đầy đủ các mô hình truyền thông IoT.\n\nDựa vào cách thức trao đổi message, ta có thể chia các mô hình truyền thông IoT thành 4 nhóm như sau:\n\nTelemetry: dữ liệu (message) di chuyển 1 chiều từ thiết bị đến hệ thống. Mục đích là gửi trạng thái của thiết bị lên phía hệ thống.\nInquiry: gửi các request của device lên hệ thống, các request này liên quan tới việc thu thập các thông tin mà thiết bị hiện tại không thu thập được. Các thông tin đó được dùng để kích hoạt một sự kiện nào đó được mô tả từ trước.\nCommand: gửi mệnh lệnh từ hệ thống tới thiết bị hoặc 1 nhóm thiết bị để bắt các thiết bị đó thực thi một công việc cụ thể, đồng thời yêu cầu trả về trạng thái thực thi công việc\nNotification: gần giống với Telemetry, ở mô hình này, thông tin cũng di chuyển 1 chiều, nhưng là từ hệ thống tới các thiết bị (chiều ngược lại so với Telemetry),\nTa có thể hình dung một cách trực quan về 4 mô hình này như sau:\n\n\n\nMỗi mô hình trên có thể cần đến việc lưu trữ dữ liệu. Khi đó, các cơ chế store & forward (lưu trữ và chuyên tiếp) sẽ được tận dụng (ví dụ: hàng đợi, topic/subscription trong các broker). Nếu bên gửi và bên nhận cùng online, ta có thể dùng các giải pháp direct message.\n\nCơ chế store & forward thường được áp dụng trong mô hình Command. Bởi vì khi gửi lệnh cho một device thì device đó có thể không online... Tình huống này lại phát sinh ra một giải pháp khác, đó là sử dụng thuộc tính TTL cho message (Time To Live). Khi device trở lại trạng thái online, TTL giúp device tránh được việc thực thi các lệnh quá cũ. Direct message thì lại được áp dụng cho mô hình Telemetry (mặc dù đôi khi lưu trữ các dữ liệu gửi bằng mô hình Telemetry vẫn có ích).\n\n \n\n#1 Mô hình Telemetry\n\nGiao thức HTTP có thể implement mô hình này theo 2 cách: hoạt động như một client, gửi PUT/POST request chứa các thông tin trạng thái cần cập nhật sang một hệ thống khác hoặc hoạt động như một server, nhận GET requests từ các hệ thống khác để thu thập dữ liệu. Trong bất kì trường hợp nào, việc implement này xoay quanh 2 hành động chính là request / reply.\n\nCó 2 hạn chế  đáng chú ý ở đây\n\nHTTP là giao thức text-based, dài dòng và không hỗ trợ QoS - Quality of Service.\n\nKhi hoạt động với vai trò là server, HTTP gặp vấn đề về kết nối với thiết bị trong mạng nếu có NAT hoặc roaming(mạng điện thoại di động)\n\n\nMinh họa về mô hình MQTT với 3 thành phần chính: Broker - subscriber và Publisher\nGiao thức triển khai mô hình Telemetry phổ biến nhất chính là MQTT. MQTT implement luôn cả mô hình publish/subscribe. Với MQTT, các device được xem như publisher - người xuất bản. Nội dung xuất bản là các dữ liệu mà device đó thu thập hoặc xử lý được. Đích đến của các dữ liệu đó là các broker. Để gom nhóm các dữ liệu thành 1 \"kênh\", MQTT sử dụng khái niệm topic.  Các hệ thống/thiết bị khác muốn lấy thông tin thì sẽ hoạt động như subscriber - người theo dõi. Hành động theo dõi này và các message tương ứng được giới hạn theo từng topic.\n\nMQTT hỗ trợ đầy đủ các QoS level.\n\nNói về nhược điểm, MQTT không hỗ trợ xử lý logic. Vì không hỗ trợ xử lý logic nên một broker có thể bị quá tải (flooded) bởi các message mà không làm cách nào để dừng nhận các message này.\n\n\n\n Một giao thức đáng chú ý khác cũng implement mô hình này, đó là AMQP. AMQP cung cấp cả 2 phương pháp trao đổi message là request/reply và publish/subscribe.\n\nSo với MQTT, AMQP có một lợi thế lớn. Đó là khả năng thiết đặt một luồng logic điều khiển cho 2 mức khác nhau: mức byte và mức message.\n\n \n\nThực hành xây dựng sản phẩm IoT trong khóa học Node JS Fullstack\n \n\n#2 Inquiry\n\nSử dụng HTTP để implement mô hình này khá đơn giản vì bản thân giao thức HTTP đã hoạt động dưới hình thức gửi request - nhận response. Do đó, khi implement theo mô hình Inquiry, việc trao đổi thông điệp với HTTP chỉ xoay quanh các GET request từ device lên hệ thống để lấy thông tin.\n\nViệc implement MQTT theo mô hình Inquiry khó khăn hơn vì ta sẽ phải define các ngữ nghĩa mới ở tầng ứng dụng để đảm bảo việc truyền thông giữa device và hệ thống tuân thủ đúng mô hình Inquiry.\n\nDevice cần subscribe một topic để nhận thông tin. Tuy nhiên không phải là nhận một cách thụ động! Khi nào device có nhu cầu thì device mới gửi request lên hệ thống. Và khi đó thì device lại đóng vai trò là publisher. Vì vậy, với giao thức MQTT, ta cần tạo thêm một mối tương quan trong hành động gửi request và reply tại tầng ứng dụng.\n\nKhác với MQTT và HTTP, AMQP đáp ứng tốt yêu cầu của việc implement mô hình Inquiry.\n\nĐiều đáng chú ý là các AMQP message (message được tạo theo chuẩn của giao thức AMQP) đều chứa nhiều thông tin hữu ích (dưới dạng metadata). Đầu tiên có thể kể đến message ID và thuộc tính reply-to. Do đó, khi device gửi yêu cầu cho hệ thống, nó có thể đưa thêm thông tin về địa điểm nhận message (address). Hệ thống sẽ hồi đáp bằng một message khác kèm theo ID tương ứng (có thể sử dụng message ID của request).\n\nMột điểm mạnh của AMQP khi implement mô hình Inquiry là tính asynchronous của giao thức này. Nhờ đặc tính asynch vốn có, các thông điệp hồi đáp từ phía hệ thống có thể đến device theo bất kỳ thứ tự nào mà không làm mất đi sự tương quan của message hồi đáp với request yêu cầu nó.\n\n\nSo sánh vui MQTT vs AMQP\n#3 Mô hình Command\n\nMô hình này hơi ngược so với Inquiry, bên bắt đầu quá trình truyền thông lại là hệ thống chứ không phải device.\n\nVới giao thức HTTP, mô hình này có thể implement bằng cách cho device nhận một trong 2 vai trò: client hoặc server. Nếu device hoạt động như một server, hệ thống sẽ gửi POST request và chờ đợi response tương ứng (synchronous) từ phía device để biết quá trình thực thi mệnh lệnh có diễn ra suôn sẻ không... Nếu device hoạt dộng như client, device sẽ gửi GET request lên hệ thống để hỏi xem có mệnh lệnh nào cần thực thi không. Nếu không có lệnh nào, client sẽ phải đợi (synchronous). Sau khi nhận và thực thi lệnh, device sẽ gửi POST request lên hệ thống để thông báo kết quả thực thi mệnh lệnh.\n\nVới giao thức MQTT, nếu muốn implement theo mô hình Command, ta cũng phải đưa ra một số ngữ nghĩa mới ở tầng ứng dụng.\n\nBản thân MQTT không hỗ trợ kiểu truyền thông request/reply nên ta cần đưa ra một số ngữ nghĩa mới như: thiết bị subscribe một topic để nhận command, hệ thông sẽ gửi command vào topic đó. Phần payload của command (từ phía hệ thống) sẽ phải chứa request ID. Sau khi thực thi mệnh lệnh, device publish kết quả kèm theo request ID tương ứng.\n\nNếu device offline, ta có thể dùng \"retain\" flag, nhờ đó, mệnh lệnh cuối cùng từ phía hệ thống sẽ được chuyển đến khi device online trở lại.\n\n \n\n\n\nMột lần nữa, AMQP lại tỏ ra vượt trội hơn khi implement mô hình Command.\n\nHệ thống có thể gửi message chứa mệnh lệnh, kèm theo message ID và thuộc tính reply-to. Sau khi thực thi mệnh lệnh, device gửi kết quả trong một message khác, kèm theo ID tương ứng với message ID của mệnh lệnh từ phía hệ thống. Message từ phía device sẽ được gửi đúng về địa chỉ mà hệ thống mong muốn nhờ thuộc tính reply-to. Việc truyền thông này cũng diễn ra không đồng bộ (asynchronous), do đó hệ thống có thể gửi hàng loạt mệnh lệnh mà vẫn nhận được response tương ứng của từng mệnh lệnh đã gửi.\n\nNếu device offline và ta chỉ muốn nó thực thi mệnh lệnh mới nhất từ phía hệ thống? Để giải quyết tình huống này, hãy sử dụng thuộc tính TTL (Time To Live) cho các mệnh lệnh gửi đi từ hệ thống.\n\n \n\n\n\n \n\n#4 Mô hình Notification\n\nMô hình này ngược với Telemetry, luồng lưu thông message thì lại gần giống với mô hình Command, tuy nhiên việc trao đổi message theo mô hình Notification không cần reply cho mỗi message nhận được.\n\n\n\nVới giao thức HTTP, device nhận notification từ hệ thống. Trong quá trình truyền thông với device, hệ thống hoạt động như một server (hệ thống sẽ gửi POST request) hoặc client (hệ thống sẽ gửi GET request). Nếu hệ thống hoạt động như một client, nó chỉ có thể reply khi notification từ phía thiết bị đã sẵn sàng (long polling) hoặc reply ngay lập tức. (device has to poll the server aditional times). Tất nhiên, khi sử dụng HTTP, các vấn đề liên quan tới NAT và roaming đưa ra ở đầu bài viết là không thể tránh khỏi.\n\nVới giao thức MQTT, device sẽ subscribe một topic. Server publish notification vào topic đó. Mọi thứ diễn ra suôn sẻ vì mô hình Notification này rất gần với cơ chế publish/subscribe của MQTT. Tuy nhiên, nếu ta không define thêm phần logic xử lý ở tầng ứng dụng, device có thể bị quá tải do liên tục nhận các notification từ topic đang subscribe.\n\nCuối cùng, với AMQP, device vừa có thể nhận notificaiton vừa có thêm phần logic xử lý giúp device ngừng nhận notification khi không đủ khả năng xử lý.\n\n\n\nNhư vậy, với 4 mô hình truyền thông IoT nêu trên, AMQP tỏ ra khá linh hoạt khi có thể implement tốt cả 4, đồng thời khắc phục được một số nhược điểm của MQTT và HTTP. Hãy đón đọc các bài viết tiếp theo của Techmaster về AMQP cũng như cách áp dụng giao thức này vào quá trình xây dựng các sản phẩm IoT.\n\n \n\nTechmaster via Dzone\n\n \n\n \n\n \n\n","Xây dựng ứng dụng Node.js với TypeScript":"Tutorial này sẽ dạy bạn cách build, cấu trúc, test và debug 1 ứng dụng Node.js viết bằng TypeScript. Để làm điều đó, chúng ta sẽ sử dụng 1 project làm ví dụ (bạn có thể truy cập nó bất cứ lúc nào).\n\nQuản lý các project Javascript lớn, yêu cầu tính mở rộng thực sự là 1 thách thức mà trong đó, bạn cần đảm bảo các mảnh của bức tranh tổng vừa khít với nhau. Bạn có thể sử dụng unit test, kiểu biến (Javascript hiện chưa có tính năng này) hay là thậm chí cả hai.\n\nNói đến đây hẳn các bạn đã nghĩ đến cái tên TypeScript. Cho những ai chưa biết thì TypeScript là superset của JavaScript, có thể biên dịch được ra Javascript thuần.\n\nTrong bài viết này, các bạn sẽ được học:\n\nTypeScript là gì?\nLợi ích khi sử dụng TypeScript.\nCác cách để set-up 1 project - cách thêm linter cho project, viết test, cách debug project TypeScript,...\nBài viết này sẽ không đi sâu vào cách sử dụng TypeScript mà tập trung vào cách xây dựng ứng dụng Node.js sử dụng TypeScript. Nếu bạn đang tìm kiếm 1 tutorial giúp hiểu sâu hơn về TypeScript thì đây là nơi bạn bắt đầu.\n\nLợi ích của việc sử dụng TypeScript\n\nNhư đã nói ở trên, TypeScript là superset của JavaScript. Nó đem đến cho bạn những lợi ích sau:\n\nStatic typing.\nSử dụng các tính năng của ECMAScript chưa được hỗ trợ bởi V8.\nSử dụng các interface.\nIntelliSense,...\nBắt đầu với TypeScript và Node\n\nTypeScript hoạt động như 1 checker static type cho JavaScript. Điều này có nghĩa rằng, Type Script sẽ đảm bảo chỉ sử dụng các tài nguyên phù hợp với mỗi kiểu dữ liệu. Ví dụ: 1 String sẽ có method toLowerCase() nhưng sẽ không có parseInt(). Dĩ nhiên bạn hoàn toàn có thể mở rộng type system của TypeScript.\n\nĐể sử dụng, đầu tiên bạn chỉ cần đổi tên phần mở rộng của file, từ .js thành .ts.\n\nChú ý: TypeScript không thực thi ở runtime mà nó chỉ hoạt động ở compiletime. Bạn cần phải chạy file JavaScript thuần.\n\nĐể bắt đầu, bạn cần cài TypeScript:\n\n$ npm install -g typescript\nGiờ thì hãy cùng bắt tay vào viết file TypeScript đầu tiên thôi! \n\n// greeter.ts\nfunction greeter(person: string) {  \n  return `Hello ${person}!`\n}\n\nconst name = 'Node Hero'\n\nconsole.log(greeter(name))  \nBạn cần chú ý ở khai báo tham số đầu vào. person: string có nghĩa rằng hàm greeter nhận vào 1 biến ( person ) có kiểu là string làm tham số.\n\nHãy compile file này bằng câu lệnh:\n\ntsc greeter.ts  \nSau khi xong quá trình compile, hãy xem qua file output. Như bạn có thể thấy, gần như không có gì khác biệt, ngoại trừ phần khai báo kiểu tham số đã biến mất.\n\nfunction greeter(person) {  \n    return \"Hello \" + person + \"!\";\n}\nvar userName = 'Node Hero';  \nconsole.log(greeter(userName));  \nĐiều gì sẽ xảy ra nếu bạn gán cho biến userName một Number? Tôi sẽ lặp lại các bước trên và nhận về lỗi khi compile:\n\ngreeter.ts(10,21): error TS2345: Argument of type '3' is not assignable to parameter of type 'string'.  \nTham khảo các khóa học lập trình online, onlab, và thực tập lập trình tại TechMaster\nTutorial: Xây dựng ứng dụng Node với TypeScript\n\n1. Cấu hình development environment\n\nĐương nhiên để xây dựng ứng dụng với TypeScript và Node, bạn cần cài đặt Node.js trên máy tính. Bài viết này sẽ sử dụng phiên bản Node.js 8.\n\nChúng tôi khuyến khích việc cài Node.js với nvm, Node.js Version Manager. Với ứng dụng đầy tiện ích này, bạn có thể có vài phiên bản Node.js trên máy tính, và chuyển đổi giữa chúng rất dễ dàng, chỉ với 1 câu lệnh.\n\n# install nvm\ncurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash\n\n# install node 8\nnvm install 8\n\n# to make node 8 the default\nnvm alias default 8  \nSau khi bạn đã cài đặt Node 8, bạn cần tạo project directory. Kế tiếp, tạo package.json bằng câu lệnh:\n\nnpm init  \n2. Cấu trúc project\n\nKhi sử dụng TypeScript, các file nên được đặt trong folder src.\n\nCuối tutorial này, cấu trúc project sẽ có dạng:\n\n\n\nHãy bắt đầu bằng việc tạo file App.ts - nơi logic của web server được thực thi, sử dụng express.\n\nTrong file này, ta sẽ tạo 1 class App, thứ sẽ làm việc như 1 encapsulator cho web server. Nó có 1 private method gọi là mountRoutes - sẽ thực hiện việc mount các route cung cấp bởi server.\n\nimport * as express from 'express'\n\nclass App {  \n  public express\n\n  constructor () {\n    this.express = express()\n    this.mountRoutes()\n  }\n\n  private mountRoutes (): void {\n    const router = express.Router()\n    router.get('/', (req, res) => {\n      res.json({\n        message: 'Hello World!'\n      })\n    })\n    this.express.use('/', router)\n  }\n}\n\nexport default new App().express  \nTa tạo thêm file index.ts để khởi động server:\n\nimport app from './App'\n\nconst port = process.env.PORT || 3000\n\napp.listen(port, (err) => {  \n  if (err) {\n    return console.log(err)\n  }\n\n  return console.log(`server is listening on ${port}`)\n})\nVậy là về cơ bản, ta đã có 1 server hoàn chỉnh. Để thực sự khiến nó làm việc, ta cần compile code TypeScript sang JavaScript. \n\nNếu bạn muốn tìm hiểu thêm về cách cấu trúc thư mục project, hãy đọc bài viết này: Cấu trúc project Node.js.\n\n3. Cài đặt TypeScript\n\nBạn có thể truyền option vào compiler TypeScript bằng cách dùng CLI hoặc bằng file config tsconfig.json. Trong bài viết này, ta sẽ sử dụng cách thứ 2: dùng file config. Theo cách này, ta có thể thiết lập cho compiler TypeScript 1 số yêu cầu: build target (ES6, ES7,..) , module system, nơi chứa file build JavaScript, có tạo source-map hay không,...\n\n{\n  \"compilerOptions\": {\n    \"target\": \"es6\",\n    \"module\": \"commonjs\",\n    \"outDir\": \"dist\",\n    \"sourceMap\": true\n  },\n  \"files\": [\n    \"./node_modules/@types/mocha/index.d.ts\",\n    \"./node_modules/@types/node/index.d.ts\"\n  ],\n  \"include\": [\n    \"src/**/*.ts\"\n  ],\n  \"exclude\": [\n    \"node_modules\"\n  ]\n}\nMột khi bạn đã có file config TypeScript, bạn có thể build ứng dụng với câu lệnh tsc. \n\nNếu bạn không muốn cài TypeScript global, hãy thêm nó vào các dependency trong project, tạo npm script cho nó:  \"tsc\": \"tsc\".\n\nNpm script sẽ tìm kiếm binary trong folder ./node_modules/.bin, thêm nó vào PATH khi chạy script. Sau đó bạn có thể chạy lệnh tsc bằng cách gõ npm run tsc. Bạn có thể truyền các option bằng cú pháp: npm run tsc -- --all (nó sẽ liệt kê tất cả các option available của TypeScrip).\n\n4. Thêm ESLint\n\nVới phần lớn các project, sử dụng các linter sẽ giúp kiểm tra các lỗi về style code. Đương nhiên, TypeScript cũng không phải ngoại lệ.\n\nĐể sử dụng ESLint, bạn phải thêm 1 package mở rộng, 1 parser để ESLint có thể hiểu TypeScript: typescript-eslint-parser. Sau khi cài đặt, bạn phải cài nó là parser cho ESLint.\n\n# .eslintrc.yaml\n---\n  extends: airbnb-base\n  env:\n    node: true\n    mocha: true\n    es6: true\n  parser: typescript-eslint-parser\n  parserOptions:\n    sourceType: module\n    ecmaFeatures: \n      modules: true\nSử dụng câu lệnh eslint src --ext ts để chạy eslint, bạn sẽ nhận được các lỗi và cảnh báo trong file:\n\n\n\n5. Test ứng dụng\n\nTest ứng dụng TypeScript là 1 công việc cần thiết, cũng như bất cứ ứng dụng Node.js nào.\n\nĐiểm khác biệt duy nhất là bạn cần compile ứng dụng trước, sau đó mới chạy các test: tsc && mocha dist/**/*.spec.js.\n\nĐể biết thêm về test, bạn có thể đọc ở đây: Node.js testing tutorials.\n\n6. Build Docker image\n\nKhi ứng dụng đã sẵn sàng, ta sẽ deploy nó dưới dạng 1 Docker image. Các bước thực hiện:\n\nBuild ứng dụng (compile từ TypeScript sang JavaScript).\nBắt đầu ứng dụng Node.js từ built source.\nFROM risingstack/alpine:3.4-v6.9.4-4.2.0\n\nENV PORT 3001\n\nEXPOSE 3001\n\nCOPY package.json package.json  \nRUN npm install\n\nCOPY . .  \nRUN npm run build\n\nCMD [\"node\", \"dist/\"]\n7. Sử dụng source-maps để debug\n\nỞ mục trên ta đã tạo source-maps, bây giờ ta sẽ dùng nó để tìm bug. Để bắt đầu tìm lỗi, cần khởi động tiến trình Node.js:\n\nnode --inspect dist/  \nOutput sẽ giống như sau:\n\nTo start debugging, open the following URL in Chrome:  \n    chrome-devtools://devtools/remote/serve_file/@60cd6e859b9f557d2312f5bf532f6aec5f284980/inspector.html?experiments=true&v8only=true&ws=127.0.0.1:9229/23cd0c34-3281-49d9-81c8-8bc3e0bc353a\nserver is listening on 3000 \nĐể bắt đầu quá trình debug, mở trình duyệt Chrome: chrome://inspect. Một remote target sẽ xuất hiện, chỉ cần ấn inspect. Quá trình sẽ khởi động Chrome DevTool.\n\nBạn có thể bắt đầu set các breakpoint, xem TypeScript source code.\n\n\n\nSource-maps chỉ hỗ trợ các phiên bản Node.js 8 hay cao hơn.\n\nHoàn thành Node.js TypeScript tutorial\n\nBạn có thể xem Node.js TypeScript starter hoàn chỉnh trên Github.\n\nBài viết được dịch từ: https://blog.risingstack.com/building-a-node-js-app-with-typescript-tutorial/\n\n","[Series bài dịch Natasha The Robot Blog] Refactoring to: Parameter Objects":"Hiện tại tôi đang đọc cuốn Refactoring to Patterns. Hôm qua, khi tôi viết về Creation Method cho một đối tượng mà có rất nhiều parameter, nó khiến tôi nghĩ đến buổi chia sẻ rất hay về Swift Patterns in iOS API Design của @modocache, đặc biệt là phần nói về Parameter Objects. Do vậy tôi đã tổng hợp lại vào thành bài viết dưới đây:\n\nHình dung bạn đang viết một thư viện có tên là BananaUIKit, trong đó có một AlertView đơn giản như sau:\n\n\n\nCode khởi tạo sẽ như sau:\n\npublic class BananaAlertView {\n    \n    public static func show(\n        withTitle title: String,\n        message: String,\n        dismissButtonText: String)\n    {\n        // implementation here\n    }\n}\nVề cơ bản thì cấu trúc code trên không có vấn đề gì cho đến khi user có yêu cầu muốn đổi BananaAlertView từ màu nâu thành màu vàng. Và để đảm bào sự thay đổi này không làm ảnh hưởng tới các phần khác, chúng ta có thể sử dụng default parameter của Swift:\n\npublic class BananaAlertView {\n    \n    public static func show(\n        withTitle title: String,\n        message: String,\n        dismissButtonText: String,\n        // new non-breaking change\n        tintColor: UIColor = .yellowColor())\n    {\n        // implementation here\n    }\n}\nMọi thứ vẫn hoạt động ổn giống như khi chúng ta thêm paremeter vào trong function, nhưng sẽ là không ổn nếu như chúng ta muốn thêm parameter vào một vài chỗ khác, như là closure để xử lý event click vào event của BananaAlertView:\n\npublic class BananaAlertView {\n    \n    // actions for when a button is clicked\n    public typealias ButtonCallback = (buttonIndex: Int) -> Void\n    \n    public static func show(\n        withTitle title: String,\n        message: String,\n        dismissButtonText: String,\n        // callback parameter\n        dismissButtonCallback: ButtonCallback)\n    {\n        // implementation here\n    }\n}\n\n// Usage\n\nBananaAlertView.show(\n    withTitle: \"This is Bananas\",\n    message: \"Someone has been monkeying around 🙈\",\n    dismissButtonText: \"Banana\",\n    dismissButtonCallback: { buttonIndex in\n        // implementation here\n    })\nĐiều gì sẽ xảy ra nếu chúng ta thay đổi parameter ở trong closure? Và nếu khách hàng cũng cần lấy ra text của button?\n\nGiải pháp ở đây là chỉ cần thêm button text như là một argument của ButtonCallback:\n\npublic typealias ButtonCallback = (buttonIndex: Int, buttonTitle: String) -> Void\nNhưng điều này sẽ phá vỡ mọi thứ, khi chúng ta gọi đến method show, ButtonCallback bây giờ sẽ phải nhận 2 argument thay vì 1 \n\n// Usage\n\nBananaAlertView.show(\n    withTitle: \"This is Bananas\",\n    message: \"Someone has been monkeying around 🙈\",\n    dismissButtonText: \"Banana\",\n    // this now breaks\n    // the closure needs to take a buttonIndex and a buttonText now\n    dismissButtonCallback: { buttonIndex in\n        // implementation here\n    })\nGiải pháp\n\nGiải pháp ở đây là tạo một parameter object cho closure:\n\npublic class BananaAlertView {\n    \n    // parameter object\n    public struct ButtonCallbackParameters {\n        let buttonIndex: Int\n        let buttonTitle: String\n    }\n    \n    // this now only takes a single parameter\n    public typealias ButtonCallback = (parameters: ButtonCallbackParameters) -> Void\n    \n    public static func show(\n        withTitle title: String,\n        message: String,\n        dismissButtonText: String,\n        dismissButtonCallback: ButtonCallback)\n    {\n        // implementation here\n    }\n}\n\nBananaAlertView.show(\n    withTitle: \"This is Bananas\",\n    message: \"Someone has been monkeying around 🙈\",\n    dismissButtonText: \"Banana\",\n    // the parameters object has all the parameters\n    // that the client will ever need!\n    dismissButtonCallback: { parameters in\n        if parameters.buttonTitle == \"Banana\" {\n            // handle it here\n        }\n    })\n  \nNếu như chúng ta phải thêm parameter thì vẫn không có vấn đề gì, buttonCallback vẫn không thay đổi.\n\n   public struct ButtonCallbackParameters {\n        let buttonIndex: Int\n        let buttonTitle: String\n        // new parameter\n        let buttonCount: Int\n    }\nVà tất nhiên là bạn có thể dễ dàng gỡ bỏ nhưng parameter mà mình không còn dùng đến nữa.\n\n   public struct ButtonCallbackParameters {\n        let buttonIndex: Int\n        // deprecate buttonTitle in next version\n        @available(*, deprecated=2.0)\n        let buttonTitle: String\n        let buttonCount: Int\n    }\nỞ những trường hợp khác thì đây cũng là một cách để refactor parameter của các method.\n\npublic class BananaAlertView {\n    \n    // view options are all things that\n    // are not essential to displaying an alert view\n    // default values can be provided here\n    public struct AlertViewOptions {\n        public let dismissButtonText = \"Bananana\"\n        public let tintColor = UIColor.yellowColor()\n        public let animationDuration: NSTimeInterval = 1\n    }\n    \n    public static func show(\n        withTitle title: String,\n        message: String,\n        options: AlertViewOptions)\n    {\n        // implementation here\n    }\n}\nCuối cùng thì cũng giống như các patterns khác, bên cạnh những cái tốt thì nó cũng có hạn chế nhất định. Ví dụ như nó có thể sẽ khiến API của bạn phình to ra, bạn sẽ không muốn phải tạo một struct cho riêng một method hay closure trong app của mình. Vì vậy, hãy sử dụng nó một cách hợp lý. Cuối cùng, bạn có thể tham khảo qua buổi nói chuyện của @modocache’s tại đây.\n\nNguồn bài viết:  https://www.natashatherobot.com/parameter-objects/\n\nTham khảo các khóa học lập trình online, onlab, và thực tập lập trình tại TechMaster\n","Hiểu về map, filter và reduce trong JavaScript":"Khi làm việc với các dự án JavaScript, chắc hẳn bạn đã trải qua các tình huống cần xử lý các dữ liệu. Những lúc ấy hẳn bạn sẽ sử dụng for-loops để giải quyết vấn đề, tuy nhiên nó sẽ ngày càng trở nên rối và làm cho code phình ra. Hầu hết trong các trường hợp, sử dụng map, filter hay reduce lại làm cho công việc trở nên dễ dàng hơn. Code của bạn sẽ \"sạch\" hơn và dễ đọc hơn. Ít nhất sẽ được như thế, khi mà bạn đã hiểu cách chúng làm việc và khi nào nên sử dụng chúng.\n\nMột số nguyên tắc mà tôi sử dụng để xác định nên dùng hàm nào:\n\nNếu tôi có 1 mảng và tôi muốn xử lý từng biến trong mảng theo cùng 1 cách, trả về các giá trị sau xử lý (số lượng đúng bằng số lượng phần tử ban đầu của mảng) thì tôi sẽ sử dụng map.\nNếu tôi đã có 1 mảng nhưng tôi chỉ muốn lấy các phần tử theo 1 tiêu chuẩn nhất định, tôi sử dụng filter.\nNếu tôi đã có 1 mảng nhưng tôi muốn sử dụng các giá trị trong mảng để tạo ra vài thứ khác hoàn toàn mới, tôi sử dụng reduce.\nCác quy tắc này nghe có vẻ mơ hồ, do đó để hiểu cách ứng dụng của từng hàm, cách tối nhất luôn là tìm hiểu qua các ví dụ. Tôi sẽ sử dụng 1 mảng mấu như dưới đây:\n\nconst animals = [\n    {\n        \"name\": \"cat\",\n        \"size\": \"small\",\n        \"weight\": 5\n    },\n    {\n        \"name\": \"dog\",\n        \"size\": \"small\",\n        \"weight\": 10\n    },\n    {\n        \"name\": \"lion\",\n        \"size\": \"medium\",\n        \"weight\": 150\n    },\n    {\n        \"name\": \"elephant\",\n        \"size\": \"big\",\n        \"weight\": 5000\n    }\n]\nHàm map()\n\nGiả sử ta cần 1 mảng chứa tên của các con vật. Nếu sử dụng for-loop:\n\nlet animal_names = [];\n\nfor (let i = 0; i < animals.length; i++) {\n    animal_names.push(animals[i].name);\n}\nNếu sử dụng hàm map():\n\nlet animal_names = animals.map((animal, index, animals) => {\n    return animal.name\n})\nHàm map() nhận vào 3 tham số (theo thứ tự):\n\nPhần tử hiện tại của mảng.\nChỉ số của phần tử hiện tại trong mảng.\nMảng ban đầu.\n1 số ưu điểm khi dùng map() thay vì for-loop:\n\nVới map(), ta không cần quản lý trạng thái của vòng lặp như với for-loop.\nTa không cần sử dụng chỉ số để truy cập vào đúng phần tử trong mảng.\nTa không cần tạo mảng mới và push() từng giá trị vào. map() trả về 1 mảng mới với các giá trị đã được chỉnh sửa, do đó có thể dễ dàng gán nó cho 1 biến khác.\nCó 1 điều bạn cần phải ghi nhớ, đó là luôn sử dụng return để trả về từng giá trị sau chỉnh sửa, nếu không mảng trả về cuối cùng sẽ chỉ chứa các giá trị undefined.\n\nTham khảo các khóa học lập trình online, onlab, và thực tập lập trình tại TechMaster\nHàm filter()\n\nTiếp tục với 1 bài toán khác, lần này ta muốn 1 mảng chỉ chứa các con vật nhỏ. Nếu dùng for-loop:\n\nlet small_animals = [];\n\nfor (let i = 0; i < animals.length; i ++) {\n    if (animals[i].size === \"small\") {\n        small_animals.push(animals[i])\n    }\n}\nSử dụng hàm filter():\n\nlet small_animals = animals.filter((animal) => {\n    return animal.size === \"small\"\n})\nHàm filter cũng nhận vào 3 tham số như hàm map(), tuy nhiên trong trường hợp này ta chỉ sử dụng tham số đầu tiên. Nó cũng có các lợi ích như hàm map(), cũng sử dụng câu lệnh return trong thân hàm. Tuy nhiên, với filter(), ta cần đảm bảo câu lệnh return trả về true hoặc false vì nó là điều kiện để \"lọc\" ra các giá trị phù hợp trong mảng.\n\nHàm reduce()\n\nHãy đến với bài toán thứ 3: bạn cần tính tổng trọng lượng của các con vật. Hãy bắt đầu với for-loop:\n\nlet total_weight = 0;\n\nfor (let i = 0; i < animals.length; i++) {\n    total_weigth += animals[i].weight\n}\nVà hàm reduce():\n\nlet total_weight = animals.reduce((weight, animal, index, animals) => {\n    return weight += animal.weight\n}, 0)\nVới hàm reduce(), các tham số truyền vào sẽ khác 1 chút so với 2 hàm kể trên:\n\nTham số đầu tiên là giá trị khởi tạo. Ta cần set giá trị khởi tạo ở cuối hàm. Trong ví dụ trên là 0. Nó có thể là bất cứ giá trị nào.\nTham số thứ 2 là phần tử hiện tại trong mảng.\nTham số thứ 3 và 4 giống với 2 hàm kể trên.\nNói lại 1 lần nữa, những lợi ích khi sử dụng reduce() cũng tương tự như map(),   filter(),  làm cho code ngắn hơn, dễ đọc hơn. Lần này, hàm reduce() trả về giá trị weight sau khi cộng, thứ sẽ lại trở thành tham số đầu tiên cho hàm reduce() kế tiếp. Khi chạy đến hàm reduce() với giá trị cuối cùng trong mảng, nó sẽ trả về tổng khối lượng các con vật (giá trị weight cuối cùng) và gán vào biến total_weight.\n\nKết luận\n\nVới các ví dụ đơn giản kể trên, ta đã hiểu hơn về cách sử dụng các hàm map, filter và reduce. Các hàm này sẽ càng tối ưu hơn với các dữ liệu hay mã code nhiều, phức tạp. Tôi khuyên bạn nên tập làm quen với chúng nếu bạn còn bỡ ngỡ. Rồi bạn sẽ nhận ra chúng giúp cho code của bạn sạch sẽ, dễ đọc và dễ bảo trì hơn.\n\nBài viết được dịch từ: https://hackernoon.com/understanding-map-filter-and-reduce-in-javascript-5df1c7eee464\n\n","Hiểu về mảng và đối tượng trong javascript":"Nếu bạn đã từng đọc sách và báo thì chắc chắn bạn sẽ hiểu được sự khác biệt giữa mảng (array) và đối tượng (object) trong JavaScript.\n\n\nKhi bạn mới bắt đầu với JavaScript, lựa chọn cách tốt nhất để sắp xếp và lưu trữ dữ liệu có thể là một nhiệm vụ khó khăn.\n\nỞ một mức độ, bạn có thể đã khá quen thuộc với mảng khi bắt đầu học về vòng lặp \"for\". Nhưng một khi quá nhiều dữ liệu được nhét vào mảng, bạn sẽ phải đối mặt với một mớ hỗn độn khó mở rộng thêm được và sẽ rất khó theo dõi và hiểu thông tin khi bạn xem lại code của mình.\n\nLựa chọn giữa mảng và đối tượng trở nên dễ dàng hơn nhiều khi bạn nhanh chóng xác định mục tiêu của từng loại. Mảng gần với cách cuốn sách lưu trữ thông tin, trong khi đối tượng tương tự như  một tờ báo lưu trữ thông tin. \n\nHãy trực tiếp xem xét từng loại nào !\n\nMảng (Arrays): Thứ Tự Của Dữ Liệu Là Điều Quan Trọng Nhất\n\nDưới đây là từng chương của một cuốn truyện ngắn theo dạng mảng \n\nvar book = ['foreword', 'boyWhoLived', 'vanishingGlass', 'lettersFromNoOne', 'afterword']; \nCuốn truyện của chúng ta gồm 3 chương đầu tiên trong cuốn đầu tiên của Harry Potter. Đây là mảng này hiển thị theo dạng hình ảnh\n\n\n\nBạn muốn sử dụng mảng khi thứ tự là điều quan trọng nhất trong việc sắp xếp dữ liệu. Tôi hi vọng không ai đọc cuốn truyện Harry Potter và nghĩ là \"Hmmm, phần này nhìn có vẻ hay đấy, hãy bỏ qua đoạn trước và đọc luôn đoạn sau này thôi!\" Thực tế, thứ tự các chương thông báo cho ta nên đọc cái nào trước, cái nào sau.\n\nKhi bạn lấy thông tin từ một mảng, bạn sử dụng index của từng thành phần trong mảng. Mảng trong JavaScript là 0-indexed, nghĩa là các phần tử trong mảng được đánh dấu từ 0 thay vì 1.\n\nKhi bạn muốn lấy dữ liệu ở index 0 của cuốn sách, chúng ta sử dụng câu lệnh:\n\nbook[0]\nKết quả trả về\n\n‘foreword’\nNếu muốn lấy tên chương thứ ba của cuốn truyện:\n\nbook[2]\nBạn chọn chương nào để đọc theo thứ tự được sắp xếp trong mục lục, chứ không dựa vào tiêu đề của chương.\n\nTham khảo các khóa học lập trình online, onlab, và thực tập lập trình tại TechMaster\nĐối Tượng (Objects) Tiêu Đề Của Thông Tin (Thuộc Tính Của Đối Tượng) Là Quan Trọng Nhất\n\nMột tờ báo theo dạng đối tượng có thể nhìn như dưới đây:\n\nvar newspaper= {\n  sports: 'ARod Hits Home Run',\n  business: 'GE Stock Dips Again',\n  movies: 'Superman Is A Flop'\n}\nTờ báo dạng hình ảnh:\n\n\n\nĐối tượng (objects) phù hợp với dữ liệu được sắp xếp theo tiêu đề. Khi bạn đọc một tờ báo, bạn thường không đọc nó lần lượt từ đầu đến cuối. Người đọc dễ dàng nhảy giữa các phần, hay chuyển đến một vài phần nhất định mà họ quan tâm. Không quan trọng là mục đấy nằm ở đâu, người đọc nhanh chóng lật được phần này và đọc thông tin cần thiết. Đây là sự khác biệt với một cuốn truyện, trong một cuốn truyện, mạch truyện và theo đó, thứ tự các chương là rất quan trọng.\n\nĐối tượng lưu trữ thông tin theo từng cặp thuộc tính/ giá trị (key/value pairs). \n\nkey: value\nNếu bạn muốn lật xem thông tin trong mục Business của tờ báo trên, thuộc tính là 'business', xem giá trị của thuộc tính này: \n\nnewspaper[‘business’]\n// hoặc\nnewspaper.business\nCâu lệnh trên trả về cho ta thông tin chứa trong thuộc tính này ''GE Stock Díps Again' . Vì vậy, khi cách lấy dữ liệu dễ nhất là dựa vào tiêu đề hay chính xác hơn là thuộc tính thì bạn nên lưu dữ liệu theo dạng đối tượng.\n\nKết Hợp Mảng Và Đối Tượng\n\nPhần trước, chúng ta nói về việc lưu thông tin trong mảng hoặc đối tượng. Thêm vào đó, bạn cũng có thể kết hợp 2 dạng này theo các cách dưới đây:\n\nMảng trong đối tượng\nĐối tượng trong mảng\nMảng trong mảng\nĐối tượng trong đối tượng\nViệc này có thể trở nên hơi phức tạp, tuy nhiên, gần như chắc chắn bạn sẽ cần những sự kết hợp này để lưu dữ liệu nhằm giúp ích cho việc mở rộng dữ liệu sau này. Bạn muốn lưu trữ theo cách mà chính bạn có thể hiểu được đoạn code của mình một tuần sau đó.\n\nHãy xem xét lại ví dụ về cuốn truyện lúc trước nào. Ví dụ nếu chúng ta cần lưu số trang của từng chương. Chúng ta có thể lưu theo các cách dưới đây\n\n// Mảng trong mảng\nvar book =[\n  [‘foreword’, 14],\n  [‘boywholived’, 18]\n]\n// Đối tượng trong mảng\nvar book = [\n  {name:'foreword', pageCount: 14},\n  {name:'boyWhoLived', pageCount: 18},\n  {name:'vanishingGlass', pageCount: 13},\n  {name:'lettersFromNoOne', pageCount: 17},\n  {name:'afterword', pageCount: 19}\n]; \nVới cách đối tượng trong mảng ở trên, mục lục của cuốn truyện vẫn được giữ nguyên, nhưng bây giờ chúng ta có thể mở rộng thuộc tính của từng chương, cũng chính là từng đối tượng bên trong mảng. Ví dụ, nếu muốn lấy số trang của chương thứ hai, ta có:\n\nbook[1][‘pageCount’]\n// book[1] lấy ra đối tượng thứ hai trong mảng {name:'boyWhoLived', pageCount: 18}\n// book[1]['pageCount'] lấy ra giá trị của thuộc tính 'pageCount' của book[1]\nKết quả trả về giá trị 18.\n\nTiếp theo, nếu ta muốn có xếp hạng của các nhà báo của từng mục trong tờ báo, dựa theo thời gian làm việc. Mảng có thể được dùng trong đối tượng tờ báo như dưới đây:\n\nvar newspaper= {\n  sports: 'ARod Hits Home Run',\n  sportsWriters: ['Miramon Nuevo', 'Rick Reilly', 'Woddy Paige'], //nhà báo mục thể thao\n  business: 'GE Stock Dips Again',\n  businessWriters: ['Adam Smith', 'Albert Humphrey', 'Charles Handy'],\n  movies: 'Superman Is A Flop',\n  moviesWriters: ['Rogert Ebert', 'Andrew Sarris', 'Wesley Morris']\n}\nMột mảng là lựa chọn thích hợp để lưu tên các nhà báo vì ta cần sắp xếp theo thứ tự (kinh nghiệm làm việc). Nhìn vào bạn có thể hiểu rằng nhà báo đứng phía trước có kinh nghiệm làm việc lâu năm hơn nhà báo phía sau. Trong mảng, nhà báo được sắp xếp từ 0, nhà báo lâu năm nhất ở index 0.\n\nBạn cũng có thể tối ưu tờ báo ở trên bằng cách tạo đối tượng bên trong đối tượng tờ báo. Ví dụ, thuộc tính 'sports' lúc này có giá trị là một đối tượng, bên trong đối tượng 'sports' có hai thuộc tính 'title' lưu đầu đề của 'sports' và thuộc tính 'writers' lưu mảng chứa các nhà báo của mục 'sports'.\n\nMột vài thử thách nhỏ cho bạn:\n\nGiả dụ ứng dụng web của bạn có phần quiz, người dùng sẽ trả lời một số câu hỏi và nhận lại điểm sau khi hoàn thành. Bạn muốn lưu tất cả câu trả lời của người dùng để sau đó có thể kiểm tra lại chúng một cách hiệu quả. Bạn nên lưu dữ liệu như thế nào? Tại sao?\nGiả dụ người dùng tạo hồ sơ mới trên trang của bạn với tên riêng, họ, email và mật khẩu. Bạn muốn lưu trữ thông tin này lại trước khi gửi về backend. Cấu trúc nào bạn sẽ dùng để lưu dữ liệu? Tại sao?\nGiả dụ bạn đang xây dựng một forum, bạn cần xếp hạng nhận xét dựa theo lượt votes. Cấu trúc dữ liệu nào phù hợp nếu bạn cần theo dõi của nội dung nhận xét và số lượng votes của từng nhận xét? Gợi ý: kết hợp 2 dạng. \nNguồn dịch: https://medium.freecodecamp.com/javascript-arrays-and-objects-are-just-like-books-and-newspapers-6e1cbd8a1746\n\n","Debug ứng dụng Node.js với Google Chrome":"Debug là 1 quá trình tìm, xác định và gỡ bỏ các lỗi có trong ứng dụng. Nó không đơn thuần chỉ là việc in ra các value nằm trong code. Bài viết này sẽ miêu tả làm thế nào để debug các ứng dụng Node.js hiệu quả, sử dụng phiên bản Google Chrome DevTool mới nhất.\n\nTại sao console.log không nên là lựa chọn tốt nhất?\n\nSử dụng console.log để debug cho ứng dụng của bạn thông thường sẽ kéo bạn vào 1 vòng lặp luẩn quẩn: tạm ngưng công việc, thêm 1 dòng console.log, khởi động lại để xem nó log ra cái gì. Điều hiển nhiên mà ai cũng có thể thấy ngay trước mắt đó là quá trình làm việc của bạn sẽ bị gián đoạn, kéo chậm lại. Điều thứ 2 là việc bạn phải thêm vào những dòng code không cần thiết để debug cho ứng dụng. Cuối cùng, việc cố log các biến giữa các tiến trình logging nền có thể khiến cho việc debug khó khăn hơn - bạn sẽ phải mò mẫm xem biến nào cần xem xét để debug.\n\nCông cụ Debug\n\nCông cụ debug cung cấp cho bạn một số chức năn quan trọng mà câu lệnh console.log không làm được. Cụ thể hơn, nó giúp bạn dừng việc thực thi của ứng dụng tại một số điểm đặc biệt trong code; xem xét, kiểm tra, xác định giá trị của các biến trong khi chương trình vẫn đang chạy.\n\nCài đặt Chrome cho quá trình debug Node.js\n\nVới phiên bản Chromw 57+, chức năng debug Node.js đã được kích hoạt mặc định, bạn không cần thiết phải kích hoạt thủ công Experimental Feature panel như trên các phiên bản cũ hơn nữa. \n\nĐể đảm bảo, hãy cập nhật Google Chrome lên phiên bản mới nhất và sử dụng 1 phiên bản Node.js 6.4+. \n\nĐể bắt đầu debug, chạy ứng dụng Node.js với cờ --inspect:\n\nnode --inspect <your_file>.js\n\nChạy ứng dụng Node.js trong chế độ Debugging\nKế tiếp, bỏ qua phần URL \"chrome-devtools://\", thay vào đó mở \"about:inspect\" trên Google Chrome.\n\n\nInspect với DevTool trên Chrome\nCuối cùng, click vào \"Open dedicated DevTools for Node\" để bắt đầu debug ứng dụng.\n\n\nDeveloper Tool cho Node.js\nTài liệu cho công việc debug ứng dụng Node.js chi tiết cho các bạn tham khảo thêm.\n\nTham khảo các khóa học lập trình online, onlab, và thực tập lập trình tại TechMaster\nChrome DevTools\n\nDưới đây là 1 cái nhìn tổng quát cho việc sử dụng Chrome DevTools với ứng dụng Express.\n\n'use strict'\n\nconst express = require('express')\nconst app = express()\n\nconst PORT = process.env.PORT || 3000\n\nfunction capitalize (str) {\n  const firstLetter = str.charAt(0) // we can check what's inside here\n  return `${firstLetter.toUpperCase()}${str.slice(1)}`\n}\n\napp.get('/:name?', (req, res) => {\n  const name = req.params.name ? capitalize(req.params.name) : 'World'\n  res.send(`Hello ${name}!`)\n})\n\napp.listen(PORT, () => console.log(`App listening on *:${PORT}`))\nHãy chạy nó với cờ --inspect và mở DevTools cho Node như đã trình bày ở trên.\n\nLúc này, bạn có thể truy cập các chức năng quen thuộc: set breakpoint, source-map cho transpiled code, kiểm tra heap snapshot, cấp phát profiling, hot-swapping các giá trị JavaScript,...\n\n\nSử dụng breakpoint để debug ứng dụng Express\nNhư hình dưới, bạn có thể chèn các breakpoint để ngừng sự thực thi của chương trình, kiểm tra và \"hot-swapping\" các giá trị của biến.\n\n\nHot-swapping giá trị JavaScript (1)\n \nHot-swapping giá trị JavaScript (2)\nMột điều tuyệt vời khác khi sử dụng Chrome làm công cụ debug đó là bạn có thể debug cả code front-end lẫn back-end trên cùng giao diện làm việc.\n\nBài viết được dịch từ: https://medium.com/the-node-js-collection/debugging-node-js-with-google-chrome-4965b5f910f4\n\n","Đào tạo lập trình viên Full Stack Node.js 2017 khoá mới":"Từ tháng 2/2017, Techmaster bắt đầu đào tạo lập trình viên Full Stack Node.js 2017. Đặc điểm của khoá học này là thực tập toàn thời gian, học viên mặc định đã phải nắm vững lập trình web front end . Trong khoá thực tập kéo dài 6 tháng này, học viên sẽ được thực hành qua các dự án, công nghệ:\n\nJavaScript front end nâng cao: JQuery, D3JS, Vue.js: xây dựng game, hoạt hình các thuật toán, giải thuật kinh điển: đệ quy, cây, tìm kiếm chiều rộng, tìm kiếm chiều sâu, quay lui...\nKiểm thử JavaScript: Mocha, Chai: rèn thói quen viết kiểm thử tự động ngay từ ngày đầu tiên\nJavaScript nâng cao: Callback, cơ chế non-blocking, async, promise: hiểu rõ bản chất vấn đề qua ứng dụng quét thư mục, nén Flac ra mp3\nTính năng mới của JavaScript 6: await-async, yield\nSocket IO: ứng dụng quan sát nhiệt độ, ứng dụng chat room, ứng dụng chơi cờ caro, ứng dựng chơi cờ caro 2 người qua mạng\nExpress thuần: GET, POST, PUT, DELETE cơ chế middleware, tạo REST, authentication, \nExpress nâng cao: Clustering, bảo mật\nTạo REST API. Phối hợp với lập trình viên di động\nCMS: Arrowjs Core vs CMS: hiện nay học viên khoá 1 đã có nhiều bạn tham gia nâng cấp CMS này\nMicroservice sử dụng ActionHero, bảo mật OAuth, JSON Web token\nCào, bóc tách dữ liệu sử dụng NightMare.js\nCơ sở dữ liệu Postgresql: cài đặt, cấu hình Postgresql trên Docker\nThư viện kết nối CSDL: pg-promise, sequelize.\nLinux: căn bản\nDocker căn bản: cài đặt, tạo image, share volume, bật, tắt, mở cổng\nNginx: cấu hình Nginx làm proxy, cài đặt https\nElastic Search: dự án ColorBank, dự án tìm kiếm địa điểm nhà hàng\nVue.js: Techmaster lựa chọn Vue.js là một framework front end chính thức bổ trợ cho chương trình thực tập này bởi vì nó đơn giản dễ học, chạy tốt trong hầu hết các sản phẩm\nReact: Techmaster có thể hướng dẫn học viên sử dụng React\nĐồ án giữa khoá học: ứng dụng Blog, CMS, thương mại điện tử\nĐồ án sản phẩm cuối khoá học: ứng dụng phải khác hoàn toàn, có sự tìm tòi sáng tạo mới\nKinh nghiệm bắt đầu, thực hiện, hoàn thiện và tung ra một sản phẩm web\nHỏi đáp nhanh xem kỹ trước khi quyết định đăng ký\n\nQ: Học phí là bao nhiêu:\nA: Học phí thực tập 2.5 triệu/tháng trong tối thiểu 4 tháng đầu tiên\nQ: Học viên không học chuyên ngành CNTT và chưa có kỹ năng lập trình có được học không?\nA: Hãy khởi động bằng khoá thực tập Lập trình web cơ bản HTML5, CSS, JavaScript. Đây là một khoá thực tập rất bổ ích, có nhiều bài tập mẫu, dự án rất hay.\nQ: Tôi có thể thực tập nửa ngày hay học trực tuyến?\nA: Chương trình này nhiều kiến thức qua thực hành và làm dự án cùng nhóm, Techmaster chỉ nhận học viên thực tập cả ngày.\nQ: Chi tiêu tuyển học viên là bao nhiêu?\nA: Hiện khoá học có 1 giảng viên chính làm việc toàn thời gian và 3 trợ giảng làm việc toàn thời gian. Do đó số lượng tuyển sinh khoảng 10 người.\nQ: Techmaster có đảm bảo công việc đầu ra?\nA: CÓ. Nếu hoàn thành 70% các bài tập dự án, học viên không xin được việc, Techmaster hoàn lại toàn bộ học phí và bồi thường thêm 2 triệu VND.\nQ: Môi trường thực tập ở Techmaster có khắc nghiệt?\nA: Hoàn toàn không khắc nghiệt. Học viên tự điều chỉnh tốc độ tiếp thu. Học nhanh, chăm chỉ thì sớm tốt nghiệp, đi làm có lương. Techmaster cấm tuyệt đối việc hút thuốc lá, sử dụng rượu bia trong giờ học. Truy cập trang tin giải trí, Facebook cũng bị hạn chế trong một số khoảng thời gian trong ngày.\nQ: Tôi hiện nay đã ngoài 30 tuổi, chưa bao giờ học CNTT liệu có theo được khoá học này?\nA: Bạn cần thực tập lớp Lập trình web cơ bản HTML5, CSS, JavaScript\nQ: Trong 6 tháng thực tập, có khi nào tôi được nhận thù lao?\nA: Có nếu bạn tham gia dự án hoặc hoàn thành xuất sắc bài tập, bạn sẽ có thưởng bằng tiền mặt\nQ: Techmaster có dạy theo kiểu cầm tay chỉ việc?\nA: Có và không. Trong 2 tháng đầu tiên, giảng viên và trợ giảng làm việc khá kỹ, chi tiết với từng học viên. Sau đó học viên được chủ động nghiên cứu tìm hiểu và làm việc bình đẳng trong nhóm thực hành.\nQ: Khoá học này có yêu cầu học viên biết tiếng Anh?\nA: Có ! Tối thiểu bạn phải đọc được tài liệu tiếng Anh\nQ: Học viên lớp Full Stack Node.js có thân thiện?\nA: Rất thân thiện và sẵn sàng giúp đỡ các học viên mới. Học viên cũ sẽ làm chung dự án với học viên mới.\nQ: Techmaster có cấp bằng cho học viên tốt nghiệp khoá học này?\nA: Không ! Hãy đi lên bằng sản phẩm cụ thể. Bạn cần bằng hay ra chợ mà mua cho nhanh.\nQ: Có phải Techmaster đang đào tạo để tận dụng nhân công lập trình Node.js giá rẻ?\nA: Không ! Giá trị cốt lõi của chúng tôi là đào tạo qua thực hành dự án. Nếu học viên làm dự án thương mại hoá có 2 khả năng:\n+ Dự án gia công, học viên cũng được thù lao theo đóng góp cụ thể. Thù lao trả vào cuối tháng\n+ Dự án sản phẩm start up: học viên tự chủ động, Techmaster tham gia hỗ trợ công nghệ, kinh nghiệm, đổi lại Techmaster nhận 5% cổ phần trong start up\nQ: Học xong khoá này, tôi có thể cạnh tranh được với sinh viên tốt nghiệp chuyên ngành CNTT ở các trường đại học uy tín\nA: Những học viên tốt nhất trong lớp thực hành Full Stack Node.js 01 thường là những bạn không học chuyên ngành CNTT hoặc bỏ học. Sản phẩm họ còn hoàn thiện và có tính thương mại hoá hơn so với hầu hết những đồ án tốt nghiệp đại học. Vấn đề cốt lõi là thái độ học, thời gian, công sức học viên bỏ ra để lập trình dự án\nQ: Tôi đã lập trình PHP, HTML thành thạo liệu có thể tham gia luôn khoá học này?\nA: Hãy demo những sản phẩm web mà bạn đã làm. Sau đó giảng viên chính sẽ tư vấn cho bạn lộ trình phù hợp.\nQ: Techmaster có lịch tuyển sinh cụ thể?\nA: Đối với học viên thực tập, chúng tôi tuyển sinh liên tục. Đăng ký lúc nào học ngay lúc đó. Techmaster không hoạt động giống như các trường đại học hay dạy nghề truyền thống, học ở Techmaster giống như học trong boot camp mô hình học công nghệ thông tin rất phổ biến tại Mỹ.\nQ: Tôi đăng ký học nhưng thấy không phù hợp liệu có được rút lại học phí?\nA: Techmaster hoàn lại học phí nếu bạn rút học phí trong 15 ngày học đầu tiên.\nQ: Tôi lo lắng vì thấy chương trình học quá nhiều công nghệ, liệu có thể học hết và học sâu trong 6 tháng?\nA: Đồng hành cùng với bạn không chỉ có giảng viên mà còn có trợ giảng và nhiều học viên cũ. Bất kỳ khi nào bạn gặp khó khăn hay hỏi bạn thực hành có kinh nghiệm hơn hoặc giảng viên. Bạn chỉ có thể học nếu thực hành liên tục qua nhiều dự án cụ thể.\n\n\n","[Series bài dịch Natasha The Robot Blog] Refactoring: Creation Method":"Như những gì tôi đã nói ở trong các buổi hội nghị gần đây, cuốn sách Refactoring to Patterns luôn được nhắc đến trong các buổi nói chuyện ưa thích của tôi. Và cuối cùng thì tôi cũng đã có thời gian để đọc nó (sau một đợt WWDC bận rộn), và tôi muốn tổng hợp lại những gì tôi đọc được tại đây để tiện tham khảo cho tương lai. Trong quá trình đọc thì tôi cũng ngộ ra được một cách ghi nhớ rất tốt, đó là dịch từ ngôn ngữ Java sang Swift.\n\nHôm nay chúng ta sẽ nói về pattern đầu tiên, đó là Creation Method.\n\nTrước khi refactor\n\nGiả dụ bạn có một model, có tên gọi là Loan( các khoản cho vay), nó có rất nhiều thuộc tính và các hàm initializer khác nhau. Ở trong trường hợp này mỗi hàm initializer được khai báo với một mục đích khác nhau - tương ứng với từng loại hình cho vay:\n\nstruct Loan {\n    let commitment: NSDecimalNumber\n    let riskRating: Float\n    let maturity: Int\n    let expiry: NSDate?\n    let capitalStrategy: String?\n    let outstanding: NSDecimalNumber?\n    \n    init(commitment: NSDecimalNumber, riskRating: Float, maturity: Int, expiry: NSDate?, capitalStrategy: String?, outstanding: NSDecimalNumber?) {\n        self.commitment = commitment\n        self.riskRating = riskRating\n        self.maturity = maturity\n        self.expiry = expiry\n        self.capitalStrategy = capitalStrategy\n        self.outstanding = outstanding\n    }\n    \n    init(commitment: NSDecimalNumber, riskRating: Float, maturity: Int) {\n        self.init(commitment: commitment, riskRating: riskRating, maturity: maturity, expiry: nil, capitalStrategy: nil, outstanding: nil)\n    }\n    \n    init(commitment: NSDecimalNumber, riskRating: Float, maturity: Int, expiry: NSDate) {\n        self.init(commitment: commitment, riskRating: riskRating, maturity: maturity, expiry: expiry, capitalStrategy: nil, outstanding: nil)\n    }\n    \n    init(commitment: NSDecimalNumber, outstanding: NSDecimalNumber, riskRating: Float, maturity: Int, expiry: NSDate) {\n        self.init(commitment: commitment, riskRating: riskRating, maturity: maturity, expiry: expiry, capitalStrategy: nil, outstanding: outstanding)\n    }\n    \n    init(capitalStrategy: String, commitment: NSDecimalNumber, riskRating: Float, maturity: Int, expiry: NSDate) {\n        self.init(commitment: commitment, riskRating: riskRating, maturity: maturity, expiry: expiry, capitalStrategy: capitalStrategy, outstanding: nil)\n    }\n    \n    init(capitalStrategy: String, commitment: NSDecimalNumber, outstanding: NSDecimalNumber, riskRating: Float, maturity: Int, expiry: NSDate) {\n        self.init(commitment: commitment, riskRating: riskRating, maturity: maturity, expiry: expiry, capitalStrategy: capitalStrategy, outstanding: outstanding)\n    }\n}\nNhìn vào trong đoạn code trên, bạn sẽ khá hoang mang không biết phải sử dụng intializer nào. Dĩ nhiên là đối với người mới thì sẽ khá lẫn lộn vì họ không nắm được rõ về nghiệp vụ này, vì vậy sẽ dẫn đến việc sử dụng nhầm intializer. Do đó chúng ta cần phải refactor lại.\n\nTham khảo các khóa học lập trình online, onlab, và thực tập lập trình tại TechMaster\nSau khi refactor\n\nĐoạn code dưới đây được gọi là refactor theo Creation Method\n\nstruct Loan {\n    let commitment: NSDecimalNumber\n    let riskRating: Float\n    let maturity: Int\n    let expiry: NSDate?\n    let capitalStrategy: String?\n    let outstanding: NSDecimalNumber?\n \n    // the original initializer can now be private\n    private init(commitment: NSDecimalNumber, riskRating: Float, maturity: Int, expiry: NSDate?, capitalStrategy: String?, outstanding: NSDecimalNumber?) {\n        self.commitment = commitment\n        self.riskRating = riskRating\n        self.maturity = maturity\n        self.expiry = expiry\n        self.capitalStrategy = capitalStrategy\n        self.outstanding = outstanding\n    }\n    \n    static func createTermLoan(commitment: NSDecimalNumber, riskRating: Float, maturity: Int) -> Loan {\n        return Loan(commitment: commitment, riskRating: riskRating, maturity: maturity, expiry: nil, capitalStrategy: nil, outstanding: nil)\n    }\n    \n    static func createTermLoan(capitalStrategy: String, commitment: NSDecimalNumber, outstanding: NSDecimalNumber, riskRating: Float, maturity: Int, expiry: NSDate) -> Loan {\n        return Loan(commitment: commitment, riskRating: riskRating, maturity: maturity, expiry: expiry, capitalStrategy: capitalStrategy, outstanding: outstanding)\n    }\n    \n    static func createRevolverLoan(commitment: NSDecimalNumber, outstanding: NSDecimalNumber, riskRating: Float, maturity: Int, expiry: NSDate) -> Loan {\n        return Loan(commitment: commitment, riskRating: riskRating, maturity: maturity, expiry: expiry, capitalStrategy: nil, outstanding: outstanding)\n    }\n    \n    static func createRevolverLoan(capitalStrategy: String, commitment: NSDecimalNumber, riskRating: Float, maturity: Int, expiry: NSDate) -> Loan {\n        return Loan(commitment: commitment, riskRating: riskRating, maturity: maturity, expiry: expiry, capitalStrategy: capitalStrategy, outstanding: nil)\n    }\n    \n    static func createRCTL(commitment: NSDecimalNumber, riskRating: Float, maturity: Int, expiry: NSDate) -> Loan {\n        return Loan(commitment: commitment, riskRating: riskRating, maturity: maturity, expiry: expiry, capitalStrategy: nil, outstanding: nil)\n    }\n}\nSau khi refactor xong thì nhìn code trở nên sáng sủa hơn hẳn, và quan trọng nhất là phân loại rõ được các hàm initializer. Bên cạnh pattern này thì còn có nhiều kiểu khởi tạo khác trong Swift tùy thuộc vào các trường hợp (ví dụ: enums), do vậy tôi sẽ sử dụng pattern này trong trường hợp muốn code của mình trở nên dễ đọc và tường minh hơn. \n\n","Năm tính năng ES6 đáng chú ý với các lập trình viên":"Học cú pháp mới là 1 điều kỳ cục. Phần lớn chúng ta chỉ học vừa đủ những cú pháp cần thiết cho công việc. Rồi đến một lúc ta thấy bạn bè/đồng nghiệp/người hướng dẫn code, ta lại thắc mắc tại sao ta lại không biết những thứ hay ho đến thế.\n\nDanh sách dưới đây chỉ gồm 5 cái gạch đầu dòng nho nhỏ mà tôi tin là sẽ giúp cho công việc code của bạn trở nên nhanh hơn.\n\nVà như mọi khi, nếu bài viết này hữu ích, hãy comment và share nhé!\n\nTemplate literals\n\nTôi phải thừa nhận rằng tính năng này rất tuyệt. Sẽ chẳng có ai lại làm như thế này...\n\nconst concatenatedString = “I am the “ + number + “ person to recommend this article.”\nkhi mà ta có thể làm như thế này:\n\nconst concatenatedString = `I am the ${number} person to recommend this article.`\nTuyệt vời!\n\nTemplate literal còn cho phép ta gọi 1 function với 1 string.\n\nXem nhé:\n\nconst consoleLogAString = (string) => {\n  console.log(string)\n}\nconsoleLogAString`I am the string to be logged!`\n// I am the string to be logged!\nNói cách khác, cú pháp này:\n\nconsoleLogAString('Here is the string!')\nhoàn toàn giống với cú pháp này:\n\nconsoleLogAString`Here is the string!`\nTemplate literal có thêm những lợi ích: truyền vào cho function 1 mảng các tham số được tách ra từ 1 string. Những tham số này được sắp xếp tuần tự: từ đầu string đến placehoder của biến đầu tiên là phần tử đầu tiên của mảng, rồi cứ thế đến cuối chuỗi.\n\nHãy xem ví dụ sau để hiểu vấn đề:\n\nfunction logOutValues(strings, value1, value2) {\n  console.log(strings, value1, value2)\n}\nlogOutValues`Here is one value: ${1} and two: ${2}. Wow!`\n// [\"Here is one value: \", \" and two: \", \". Wow!\"] 1 2\nHoặc điều khiển dữ liệu như ví dụ dưới:\n\nconst person = {\n  name: \"Scott\",\n  age: 25\n}\nfunction experience(strings, name, age) {\n  const str0 = strings[0]; // \"that \"\n  const str1 = strings[1]; // \" is a \"\n  let ageStr = 'youngster'; \n  if (age > 99){\n    ageStr = 'centenarian';\n  }\n  return str0 + name + str1 + ageStr;\n}\nconst output = experience`that ${ person.name } is a ${ person.age }`;\nconsole.log(output);\n// that Scott is a youngster\n(Cảm ơn Domenico Matteo đã 'clean code' cho phần này)\n\nTính năng này cũng cho phép bạn nhúng DSL với chuỗi escape (xem thêm ở đây).\n\nNó hữu dụng như thế nào?\n\nTính năng này cho phép chúng ta gọi function với các string theo 1 cách rất 'trong sáng'. Hãy cùng đến với ví dụ về thư viện styled_component cho React:\n\nconst Title = styled.h1`\n  font-size: 1.5em;\n  text-align: center;\n  color: palevioletred;\n`;\nTham khảo các khóa học lập trình online, onlab, và thực tập lập trình tại TechMaster\nImplicit return\n\nĐã bao nhiêu lần bạn viết 1 function trả về 1 giá trị?\n\nconst addOne = (num) => {\n  return num + 1\n}\nconsole.log(addOne(1))\n// 2\nTrả lời: mọi lúc.\n\nHãy đổi mới với cách implicit return trong ES6:\n\nconst addOne = (num) => (\n  num + 1\n)\nconsole.log(addOne(1))\n// 2\nhay thậm chí là còn rút gọn được hơn nữa:\n\nconst addOne = num => num + 1\nconsole.log(addOne(1))\n// 2\nNó hữu dụng như thế nào?\n\nÍt code hơn. Dễ đọc hơn.\n\nTạo động lực cho bạn viết các function nhỏ hơn, do đó bạn có thể tránh được những đoạn code nhiều dòng.\n\nCuối cùng thì nó cũng khá \"đẹp\" đấy chứ!\n\n\n\nArgument destructure kết hợp với Default argument\n\nTrong trường hợp bạn chưa nghe nói đến Argument destructure thì dưới đây là ví dụ:\n\nconst person = { name: 'Scott', attractiveness: 8.5 }\nconst consoleLogAttributes = ({ name, attractiveness }) => {\n  console.log(name, attractiveness)\n}\nconsoleLogAttributes(person)\n// 'Scott', 8.5\nRất hữu ích! Tuy nhiên nếu ta gọi function mà không truyền tham số vào thì sao?\n\nconsoleLogAttributes()\n// TypeError: Cannot match against 'undefined' or 'null'.\nKhông ổn 1 chút nào. Hãy sửa lỗi bằng cách thêm default argument - trong trường hợp này là 1 object rỗng:\n\nconst consoleLogAttributes = ({ name, attractiveness } = {}) => {\n  console.log(name, attractiveness)\n}\nBây giờ:\n\nconsoleLogAttributes()\n// undefined undefined\nNếu gọi hàm mà không truyền tham số thì sẽ không xuất hiện lỗi nữa. Hãy thử thêm 1 vài thứ nữa xem sao...\n\nconst consoleLogAttributes = ({ \n  name = 'Default name', \n  attractiveness = '10' \n} = {}) => {\n  console.log(name, attractiveness)\n}\nDefault ở mọi chỗ! Khi ta viết hàm như trên, kết quả sẽ trả về giống nhau trong cả 2 trường hợp dưới:\n\nconsoleLogAttributes()\n// 'Default name', 10\nconsoleLogAttributes({})\n// 'Default name', 10\nNó hữu dụng như thế nào?\n\nFunction bạn viết sẽ báo lỗi đầu vào hơn do nó đã được sửa để đáp ứng các biến đầu vào dạng undefine.\n\nMột điểm trừ đó là nó làm cho function trở nên rườm rà hơn, tuy nhiên nếu so với điểm lợi của nó thì quả thực không đáng kể.\n\n\n\nProperty value shorthand\n\nHãy sử dụng lại object person phía trên. Đây là 1 pattern thông dụng - bạn có 1 biến và bạn muốn gán cho 1 key giá trị của biến đó:\n\nconst name = \"Scott\"\nconst person = { name: name }\n// { name: \"Scott\" }\nES6 làm cho nó trở nên đơn giản hơn nhiều:\n\nconst name = \"Scott\"\nconst person = { name }\n// { name: \"Scott\" } \nThử nó với nhiều biến hơn xem nào:\n\nconst name = \"Scott\"\nconst programmingAbility = \"poor\"\nconst person = { name, programmingAbility }\n// { name: \"Scott\", programmingAbility: \"poor\" }\nThử nó với function luôn:\n\nconst name = “Scott”\nconst sayName = function() { console.log(this.name) }\nconst person = { name, sayName }\n// { name: “Scott”, sayName: function() { console.log(this.name) }  }\nSao không thử khai báo function ngay trong khai báo object nhỉ?\n\nconst name = “Scott”\nconst person = { name, sayName() { console.log(this.name) } }\n// { name: “Scott”, sayName: function() { console.log(this.name) }  }\nNó hữu dụng như thế nào?\n\nRất ngắn gọn: code ngắn và \"sạch\" hơn.\n\n\n\nMap()\n\nGiả sử bạn có 1 object với 100 cặp key - value, bạn muốn lặp qua mỗi phần tử và log ra giá trị của nó.\n\nThông thường bạn sẽ làm theo cách này:\n\nconst targetObject = { 1: 'one', 2: 'two' }\nObject.keys(targetObject).forEach(key => {\n  console.log(targetObject[key])\n}\n// 'one'\n// 'two'\nTrông không khả quan cho lắm. Đấy là còn chưa tính đến việc bạn không thể trực tiếp lặp qua các thuộc tính của 1 object.\n\nTuy nhiên nó chỉ còn là dĩ vãng:\n\nconst map = new Map([[1, 'one'][2, 'two']])\nmap.forEach(val => {\n  console.log(val)\n}\n// 'one'\n// 'two'\nỞ trên ta tạo 1 map bằng cách truyền vào constructor của 1 mảng các cặp key - value.\n\nmap sẽ có dạng:\n\nMap(2) {1 => \"one\", 2 => \"two\"}\nBạn có thể truy cập và thay đổi giá trị của chúng bằng get và set:\n\nmap.get(1)\n// 'one'\nmap.set(3, 'three')\n// Map(3) {1 => \"one\", 2 => \"two\", 3 => \"three\"}\nBạn cũng có thể sử dụng các method của array như forEach và lặp qua các giá trị của map. Công việc cũng rất dễ dàng khi bạn muốn lấy kích thước 1 map.\n\nconst objectSize = Object.keys(object).length\nconst mapSize = map.size\nMột điều cuối cùng là bạn có thể sử dụng bất cứ cái gì để làm key cho map, không giống như với object: ngày, function, object,... Do đó bạn hoàn toàn có thể có 1 map với key là ngày, value là dữ liệu tương ứng với ngày đó.\n\nNó hữu dụng như thế nào?\n\nMap hoạt động như object, với các chức năng của 1 array.\n\nĐiều này giúp cho code \"sạch\" hơn, đơn giản hơn khi lập trình viên cần phải làm việc với object thuần - cấu trúc của nó cũng rất tốt với các lệnh set và get.\n\nMap cũng rất thoải mái khi cho phép bạn làm việc với mọi kiểu key, giúp cho bạn tùy biến dễ hơn rất nhiều.\n\n\n\nBài viết được dịch từ: https://engineering.musefind.com/five-es6-features-to-make-your-life-easier-8c6a9518219f\n\n","[Series bài dịch Natasha The Robot Blog] Swift: Khi nào thì sử dụng if và guard ?":" \nNatasha Murashev là một cựu nhân viên FBI, một nữ lập trình viên rất nổi tiếng trong cộng đồng lập trình nói chung và iOS nói riêng. Cô cũng là thành viên của trang web NSHipster và là chủ nhân của blog Natasha The Robot, bắt đầu từ hôm nay, Techmaster sẽ dịch các bài blog hàng ngày của Natasha trên trang này để các bạn dễ dàng tham khảo và nghiên cứu hơn.\n\nGần đây có một thứ khiến tôi để ý trong code của mình đó là tôi thường sử dụng guard và if. Thực tế là mỗi tôi hay thay thế if bằng guard mỗi khi có thể.\n\nNhưng đó chính là vấn đề, có một sự khác biệt giữa guard và if và chúng ta cần phải cân nhắc sử dụng cái nào cho hợp lý. Đầu tiên đó là guard nên được dùng khi bạn muốn giá trị chắc chắn được sử dụng trong function để thực thi.\n\nVí dụ trong ứng dụng  try! Swift app, ở hình bên dưới, khi chúng ta muốn hiển thị một presentation session type, thì tiêu đề của presentation chính là tiêu đề của session.\n\n\n\nTuy nhiên, không phải session nào cũng có bài presentation, do vậy đối tượng presentation là kiểu optional, nhưng với session type, đó là một đối tượng được xác định là sẽ luôn tồn tại, do vậy đây là case thích hợp để sử dụng guard.\n\n     \n \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\t\t\t\n@objc public enum SessionType: Int {\n\n\n\t\t\t\n    case workshop\n\n\n\t\t\t\n    case meetup\n\n\n\t\t\t\n    case breakfast\n\n\n\t\t\t\n    case announcement\n\n\n\t\t\t\n    case talk\n\n\n\t\t\t\n    case lightningTalk\n\n\n\t\t\t\n    case sponsoredDemo\n\n\n\t\t\t\n    case coffeeBreak\n\n\n\t\t\t\n    case lunch\n\n\n\t\t\t\n    case officeHours\n\n\n\t\t\t\n    case party\n\n\n\t\t\t\n}\n\n\n\t\t\t\n \n\n\n\t\t\t\npublic class Session: Object {\n\n\n\t\t\t\n    // this is optional because not all sessions have presentations\n\n\n\t\t\t\n    // e.g. no presentation during breakfast\n\n\n\t\t\t\n    open dynamic var presentation: Presentation?\n\n\n\t\t\t\n    // other properties here\n\n\n\t\t\t\n \n\n\n\t\t\t\n    /** The main name of this session */\n\n\n\t\t\t\n    public var formattedTitle: String {\n\n\n\t\t\t\n              \n\n\n\t\t\t\n        switch self.type {\n\n\n\t\t\t\n        case .talk, .lightningTalk:\n\n\n\t\t\t\n            // for the talk / lighting talk session type\n\n\n\t\t\t\n            // we expect the presentation to be there\n\n\n\t\t\t\n            // if it's not there, it's a fail, so `guard` is used\n\n\n\t\t\t\n            guard let presentation = presentation else { return defaultTitle }\n\n\n\t\t\t\n            return presentation.localizedTitle\n\n\n\t\t\t\n        // other cases continued...\n\n\n\t\t\t\n        }\n\n\n\t\t\t\n    }\n\n\t\t\t\nTalk title phải luôn có giá trị để hiển thị. Nếu không thì app sẽ crash. Đó là lý do vì sao chúng ta sử dụng guard để \"bảo vệ\" app trong trường hợp này.\n\nỞ một trường hợp khác. Coffee Break session có thể có nhà tài trợ, trong case này, tiêu đề của coffee break sẽ kèm theo cả tê ncuar nhà tài trợ. Logic sẽ là, nếu có nhà tài trợ, chúng ta sẽ thêm tên nhà tài trợ vào khi hiển thị, còn không thì thôi. Ở đây, if sẽ là phương án tối ưu hơn.\n\n \n\n     \n \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\t\t\t\npublic class Session: Object {\n\n\n\t\t\t\n \n\n\n\t\t\t\n    /** A sponsor, if any, responsible for this session. */\n\n\n\t\t\t\n    open dynamic var sponsor: Sponsor?\n\n\n\t\t\t\n \n\n\n\t\t\t\n    /** The main name of this session */\n\n\n\t\t\t\n    public var formattedTitle: String {\n\n\n\t\t\t\n              \n\n\n\t\t\t\n        switch self.type {\n\n\n\t\t\t\n        case .coffeeBreak:\n\n\n\t\t\t\n            // some sessions are sponsored, some aren't\n\n\n\t\t\t\n            // it's not a fail if there is no sponsor\n\n\n\t\t\t\n            // so `if` is used\n\n\n\t\t\t\n            if let sponsor = sponsor {\n\n\n\t\t\t\n                return \"Coffee Break, by \\(sponsor.name)\".localized()\n\n\n\t\t\t\n            }\n\n\n\t\t\t\n            return \"Coffee Break\".localized()\n\n\n\t\t\t\n        // other cases continued...\n\n\n\t\t\t\n        }\n\n\n\t\t\t\n    }\n\n\t\t\t\nTổng kết lại thì:\n\nGiống như câu lệnh if, guard thực thi các câu lệnh dựa trên giá trị Boolean, nhưng ngược với if, guard chỉ thực thi khi điều kiện không thỏa mãn. Thay vì crash app, bạn sẽ \"nhẹ nhàng\" thoát ra khỏi khối lệnh đó và thực thi các khối lệnh tiếp theo. Đúng như định nghĩa, guard là một tấm khiên bảo hộ cho app của bạn vậy.\n\n \n\n","Top 5 thư viện iOS đặc sắc nhất trong năm 2017":"\nThời gian qua dư luận chủ yếu hướng về sự ra đời của ngôn ngữ lập trình Kotlin của Adroid, tuy nhiên chúng ta cũng đừng quên rằng iOS vẫn còn đó. Dưới đây là 5 thư viện iOS xuất sắc nhất mà chúng tôi tổng hợp được cho đến thời điểm hiện tại.\n\n1. Pastel\n\n \n\nThư viện này cho phép bạn tạo một gradient động như bạn vẫn thấy ở trong thiết kế của Instagram. Bạn có thể tự chọn màu theo ý thích và hướng chuyển động của animation, cũng như thời gian của animation.\n\n2. SpreadsheetView\n\n \n\nVới SpreadsheetView bạn có thể thiết kế một layout dạng các ô tính giống như trong Excel. Nó có rất nhiều tính năng như header tĩnh, cuộn theo các hướng, merge cell và một số tính năng mà chúng ta thường thấy ở trong Excel. Nếu như bạn đã làm việc với CollectionView, bạn sẽ không gặp phải bất kỳ một vấn đề nào khi implement thư viện này, và kể cả là bạn chưa từng làm thì nó cũng không có gì là khó cả.\n\n\n\nTham khảo các khóa học lập trình online, onlab, và thực tập lập trình tại TechMaster\n3. NotificationBanner\n\nNotification banners không chỉ mang một cái nhìn mới cho UI của bạn tới một tầm cao mới, mà còn rất hữu dụng cho việc show các trạng thái của notification của bạn. \n\n \n\nNotificationBanner cho phép bạn dễ dàng kéo thả các banner vào trong ứng dụng của mình và ẩn chúng chỉ bằng một cú tap. Nó cũng hỗ trợ cho NSAttributedString, custom UIViews và custom color, do vậy bạn có thể dễ dàng tùy chỉnh để phù hợp với project của mình. \n\n4. TLPhotoPicker\n\nTương tự với trình chọn ảnh của Facebook, TLPhotoPicker cho phép ứng dụng của bạn chọn nhiều ảnh và video cùng một lúc trên iOS, cũng như hiển thị số item đc chọn và hiển thị thời lượng của video. Và đặc biệt là hiệu ứng chạy demo ngay trong lúc chọn.\n\n \n\n5. FlexibleImage\n\n \n\nThư viện này cho phép bạn đặt filter, blend và các hiệu ứng khác cho tấm ảnh của bạn. Nó hoạt động theo cơ chế method chaining, tức là bạn có thể đặt lần lượt từng hiệu ứng theo thứ tự ý muốn của mình, và thuật toán sẽ xử lý để cho ra một bức ảnh với một hiệu ứng tổng hợp như bạn thấy trên ảnh ví dụ.\n\n"}